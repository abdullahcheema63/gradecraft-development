RSpec.describe PageviewEventLogger, type: :event_logger do
  subject { described_class.new(request: request) }
  let(:request) { double(:request).as_null_object }

  before do
    allow(Time).to receive(:now) { Date.parse("Oct 20 1999").to_time }
  end

  it "has a queue" do
    expect(described_class.queue).to eq :pageview_event_logger
  end

  it "has an accessible :page attribute" do
    subject.page = "waffles"
    expect(subject.page).to eq "waffles"
  end

  it "includes EventLogger::Enqueue" do
    expect(subject).to respond_to(:enqueue_in_with_fallback)
  end

  it "has an #event_type" do
    expect(subject.event_type).to eq "pageview"
  end

  it "inherits from the ApplicationEventLogger" do
    expect(described_class.superclass).to eq ApplicationEventLogger
  end

  describe "#event_attrs" do
    before do
      allow(subject).to receive(:page) { "some great page" }
    end

    it "merges the page from the original request with the application_attrs" do
      expect(subject.event_attrs).to eq \
        subject.application_attrs.merge(page: "some great page")
    end
  end

  describe "#page" do
    let(:result) { subject.page }
    let(:request_path) { "/path/to/chaos" }

    before do
      allow(request).to receive(:original_fullpath) { request_path }
    end

    it "gets the original fullpath from the request" do
      expect(result).to eq request_path
    end

    it "caches the #page" do
      result
      expect(request).not_to receive(:try).with(:original_fullpath)
      result
    end

    it "sets the page to @page" do
      result
      expect(subject.instance_variable_get(:@page)).to eq(request_path)
    end
  end

  describe "#build_page_from_params" do
    let(:result) { subject.build_page_from_params }
    before(:each) { allow(subject).to receive(:params) { params } }

    context "params exists" do
      context "neither params[:url] nor params[:tab] exist" do
        let(:params) { { stuff: "dude" } }
        it "returns nil" do
          expect(result).to be_nil
        end
      end

      context "params[:url] and params[:tab] both exist" do
        let(:params) { { url: "http://some.url", tab: "#greatness" } }

        it "builds a string from the params :url and :tab values" do
          expect(result).to eq "http://some.url#greatness"
        end

        it "sets @page to the string built from \#{url}\#{tab}" do
          result
          expect(subject.page).to eq "http://some.url#greatness"
        end
      end
    end

    describe "#enqueue_in_and_check_with_fallback" do
      let(:enqueue_time) { Faker::Time.forward 1 }

      # context "when the underlying document has exceeded the maximum allowable size" do
      #   before(:each) { allow(subject).to receive(:documents_exceeded_maximum_size?).and_return true }

      #   it "raises an exception" do
      #     expect{ subject.enqueue_in_and_check_with_fallback(enqueue_time) }.to \
      #       raise_error EventLogger::Exceptions::DocumentSizeExceededError
      #   end

      #   it "does not enqueue the job" do
      #     expect(subject).to_not receive(:enqueue_in_with_fallback)
      #     subject.enqueue_in_and_check_with_fallback(enqueue_time) rescue nil
      #   end
      # end

      context "with the underlying document has not exceeded the maximum allowable size" do
        before(:each) { allow(subject).to receive(:documents_exceeded_maximum_size?).and_return false }

        it "enqueues the job" do
          expect(subject).to receive(:enqueue_in_with_fallback).with(enqueue_time).once
          subject.enqueue_in_and_check_with_fallback enqueue_time
        end
      end
    end

    context "params does not exist" do
      let(:params) { nil }
      it "returns nil" do
        expect(result).to be_nil
      end
    end
  end
end
